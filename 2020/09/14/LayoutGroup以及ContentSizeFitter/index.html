<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="声明：本文为 jechyang原创文章，欢迎转载，请在明显位置注明出处。 开发过程中在集成ui的时候，有时会出现”Parent has a type of layout group component.A child of a layout group should not have a Content Size Fitter component, since it should be drive">
<meta property="og:type" content="article">
<meta property="og:title" content="LayoutGroup以及ContentSizeFitter">
<meta property="og:url" content="http://example.com/2020/09/14/LayoutGroup%E4%BB%A5%E5%8F%8AContentSizeFitter/index.html">
<meta property="og:site_name" content="乱世浮生">
<meta property="og:description" content="声明：本文为 jechyang原创文章，欢迎转载，请在明显位置注明出处。 开发过程中在集成ui的时候，有时会出现”Parent has a type of layout group component.A child of a layout group should not have a Content Size Fitter component, since it should be drive">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-09-14T07:20:53.728Z">
<meta property="article:modified_time" content="2020-09-18T04:47:26.296Z">
<meta property="article:author" content="Jechyang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2020/09/14/LayoutGroup%E4%BB%A5%E5%8F%8AContentSizeFitter/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>LayoutGroup以及ContentSizeFitter | 乱世浮生</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">乱世浮生</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/14/LayoutGroup%E4%BB%A5%E5%8F%8AContentSizeFitter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jechyang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱世浮生">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LayoutGroup以及ContentSizeFitter
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-14 15:20:53" itemprop="dateCreated datePublished" datetime="2020-09-14T15:20:53+08:00">2020-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 12:47:26" itemprop="dateModified" datetime="2020-09-18T12:47:26+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UGUI%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">UGUI源码阅读</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/09/14/LayoutGroup%E4%BB%A5%E5%8F%8AContentSizeFitter/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/09/14/LayoutGroup%E4%BB%A5%E5%8F%8AContentSizeFitter/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>声明：本文为 jechyang原创文章，欢迎转载，请在明显位置注明出处。</strong></p>
<p>开发过程中在集成ui的时候，有时会出现”<strong>Parent has a type of layout group component.A child of a layout group should not have a Content Size Fitter component, since it should be driven by the layout group</strong>“的warning，其实就是告诉我们，父节点已经有一个layoutGroup了，即使使用contentSizeFitter，也是应该父节点使用来控制子节点的size，那么这里是如何实现控制的呢，如何集成才能不出现这个warning呢，这里通过源码的阅读来解答这个问题。</p>
<a id="more"></a>

<p>这里可以先直接给出去除warning的方法，LayoutGroup勾选ChildControlSize，然后LayoutGroup挂ContentSizeFitter，就可以使用child的PreferredSize/MinSize来控制child了，只要child之间能通过LayoutGroup来传递size，都不用再挂contentsizefitter。</p>
<h2 id="HorizontalLayoutGroup和VerticalLayoutGroup"><a href="#HorizontalLayoutGroup和VerticalLayoutGroup" class="headerlink" title="HorizontalLayoutGroup和VerticalLayoutGroup"></a>HorizontalLayoutGroup和VerticalLayoutGroup</h2><p>这两个类其实都继承自类<strong>HorizontalOrVerticalLayoutGroup</strong>只是对相同方法的不同调用而已，直接以HorizontalLayoutGroup为例进行代码展示</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HorizontalLayoutGroup</span> : <span class="title">HorizontalOrVerticalLayoutGroup</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">HorizontalLayoutGroup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">CalculateLayoutInputHorizontal</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">base</span>.CalculateLayoutInputHorizontal();</span><br><span class="line">        CalcAlongAxis(<span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">CalculateLayoutInputVertical</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        CalcAlongAxis(<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">SetLayoutHorizontal</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        SetChildrenAlongAxis(<span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">SetLayoutVertical</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        SetChildrenAlongAxis(<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HorizontalOrVerticalLayoutGroup"><a href="#HorizontalOrVerticalLayoutGroup" class="headerlink" title="HorizontalOrVerticalLayoutGroup"></a>HorizontalOrVerticalLayoutGroup</h2><p>这个类才是我们水平布局和垂直布局主要实现的地方，直接从上面调用的方法依次看下来，这里需要先说明的是，<strong>不管是Calculate的方法，还是SetLayout的方法，我们都是先进行Horizontal方向上的，再进行Vertical方向上的</strong>，这个在后面的代码中可以看到。</p>
<h3 id="计算布局部分"><a href="#计算布局部分" class="headerlink" title="计算布局部分"></a>计算布局部分</h3><p>首先是调用了<strong>base.CalculateLayoutInputHorizontal</strong>这个方法，在LayoutGroup里面定义，其实这里调用的四个方法LayoutGroup里也只实现了这个方法，其他都是virtual的空函数体，其实这个方法作用<strong>就是获取子节点的所有RectTransform并且去除那些挂有IgnoreLayout属性的节点</strong>。代码如下</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CalculateLayoutInputHorizontal</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_RectChildren.Clear();</span><br><span class="line">    <span class="keyword">var</span> toIgnoreList = ListPool&lt;Component&gt;.Get();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rectTransform.childCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> rect = rectTransform.GetChild(i) <span class="keyword">as</span> RectTransform;</span><br><span class="line">        <span class="keyword">if</span> (rect == <span class="literal">null</span> || !rect.gameObject.activeInHierarchy)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">        rect.GetComponents(<span class="keyword">typeof</span>(ILayoutIgnorer), toIgnoreList);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (toIgnoreList.Count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_RectChildren.Add(rect);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; toIgnoreList.Count; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> ignorer = (ILayoutIgnorer)toIgnoreList[j];</span><br><span class="line">            <span class="keyword">if</span> (!ignorer.ignoreLayout)</span><br><span class="line">            &#123;</span><br><span class="line">                m_RectChildren.Add(rect);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListPool&lt;Component&gt;.Release(toIgnoreList);</span><br><span class="line">    m_Tracker.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着就是在HorizontalOrVerticalLayoutGroup中实际调用的方法，其实也就是调用了<strong>CalcAlongAxis</strong>方法，代码如下</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">CalcAlongAxis</span>(<span class="params"><span class="keyword">int</span> axis, <span class="keyword">bool</span> isVertical</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> combinedPadding = (axis == <span class="number">0</span> ? padding.horizontal : padding.vertical);</span><br><span class="line">    <span class="keyword">bool</span> controlSize = (axis == <span class="number">0</span> ? m_ChildControlWidth : m_ChildControlHeight);</span><br><span class="line">    <span class="keyword">bool</span> childForceExpandSize = (axis == <span class="number">0</span> ? childForceExpandWidth : childForceExpandHeight);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> totalMin = combinedPadding;</span><br><span class="line">    <span class="keyword">float</span> totalPreferred = combinedPadding;</span><br><span class="line">    <span class="keyword">float</span> totalFlexible = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> alongOtherAxis = (isVertical ^ (axis == <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rectChildren.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        RectTransform child = rectChildren[i];</span><br><span class="line">        <span class="keyword">float</span> min, preferred, flexible;</span><br><span class="line">        GetChildSizes(child, axis, controlSize, childForceExpandSize, <span class="keyword">out</span> min, <span class="keyword">out</span> preferred, <span class="keyword">out</span> flexible);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (alongOtherAxis)</span><br><span class="line">        &#123;</span><br><span class="line">            totalMin = Mathf.Max(min + combinedPadding, totalMin);</span><br><span class="line">            totalPreferred = Mathf.Max(preferred + combinedPadding, totalPreferred);</span><br><span class="line">            totalFlexible = Mathf.Max(flexible, totalFlexible);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            totalMin += min + spacing;</span><br><span class="line">            totalPreferred += preferred + spacing;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Increment flexible size with element&#x27;s flexible size.</span></span><br><span class="line">            totalFlexible += flexible;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!alongOtherAxis &amp;&amp; rectChildren.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        totalMin -= spacing;</span><br><span class="line">        totalPreferred -= spacing;</span><br><span class="line">    &#125;</span><br><span class="line">    totalPreferred = Mathf.Max(totalMin, totalPreferred);</span><br><span class="line">    SetLayoutInputForAxis(totalMin, totalPreferred, totalFlexible, axis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是<strong>combinedPadding</strong>,<strong>controlSize</strong>以及<strong>childForceExpandSize</strong>三个参数，分别对应控件面板上的参数选项，就不再多说，比较难以理解的可能是<strong>alongOtherAxis</strong>这个参数，这个参数的意思就是在计算布局的时候是否在计算它对应的轴向，举个例子，如果我们在HorizontalLayoutGroup中计算当前垂直方向上的大小，这个值就是true。</p>
<p>理解了参数含义之后接着往下看，接下来就是分别获取子节点的preferredSize, minSize,以及flexibleSize的大小，即<strong>GetChildSizes</strong>方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetChildSizes</span>(<span class="params">RectTransform child, <span class="keyword">int</span> axis, <span class="keyword">bool</span> controlSize, <span class="keyword">bool</span> childForceExpand,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">out</span> <span class="keyword">float</span> min, <span class="keyword">out</span> <span class="keyword">float</span> preferred, <span class="keyword">out</span> <span class="keyword">float</span> flexible</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!controlSize)</span><br><span class="line">    &#123;</span><br><span class="line">        min = child.sizeDelta[axis];</span><br><span class="line">        preferred = min;</span><br><span class="line">        flexible = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        min = LayoutUtility.GetMinSize(child, axis);</span><br><span class="line">        preferred = LayoutUtility.GetPreferredSize(child, axis);</span><br><span class="line">        flexible = LayoutUtility.GetFlexibleSize(child, axis);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (childForceExpand)</span><br><span class="line">        flexible = Mathf.Max(flexible, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们在面板中的参数就决定了如何去计算child的size，如果是非contolSize的话，就直接使用child的rect的size来作为min以及preferred的值，如果没有勾选childForceExpand的话flexible就为0，即当我们什么都不勾选的时候，child的size就是面板里的值。这种就适合静态界面的布局。</p>
<p>然后就是<strong>controlSize</strong>的情况，我们会调用<strong>LayoutUtility.GetXxxxxSize</strong>方法进行获取大小，这个直接用其中一个方法来看即可，在这里使用<strong>GetPreferredSize</strong>方法来进行举例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">GetPreferredSize</span>(<span class="params">RectTransform rect, <span class="keyword">int</span> axis</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (axis == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> GetPreferredWidth(rect);</span><br><span class="line">    <span class="keyword">return</span> GetPreferredHeight(rect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">GetPreferredWidth</span>(<span class="params">RectTransform rect</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Mathf.Max(GetLayoutProperty(rect, e =&gt; e.minWidth, <span class="number">0</span>), GetLayoutProperty(rect, e =&gt; e.preferredWidth, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">GetLayoutProperty</span>(<span class="params">RectTransform rect, System.Func&lt;ILayoutElement, <span class="keyword">float</span>&gt; property, <span class="keyword">float</span> defaultValue, <span class="keyword">out</span> ILayoutElement source</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    source = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (rect == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> min = defaultValue;</span><br><span class="line">    <span class="keyword">int</span> maxPriority = System.Int32.MinValue;</span><br><span class="line">    <span class="keyword">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class="line">    rect.GetComponents(<span class="keyword">typeof</span>(ILayoutElement), components);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; components.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> layoutComp = components[i] <span class="keyword">as</span> ILayoutElement;</span><br><span class="line">        <span class="keyword">if</span> (layoutComp <span class="keyword">is</span> Behaviour &amp;&amp; !((Behaviour)layoutComp).isActiveAndEnabled)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> priority = layoutComp.layoutPriority;</span><br><span class="line">        <span class="comment">// If this layout components has lower priority than a previously used, ignore it.</span></span><br><span class="line">        <span class="keyword">if</span> (priority &lt; maxPriority)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">float</span> prop = property(layoutComp);</span><br><span class="line">        <span class="comment">// If this layout property is set to a negative value, it means it should be ignored.</span></span><br><span class="line">        <span class="keyword">if</span> (prop &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this layout component has higher priority than all previous ones,</span></span><br><span class="line">        <span class="comment">// overwrite with this one&#x27;s value.</span></span><br><span class="line">        <span class="keyword">if</span> (priority &gt; maxPriority)</span><br><span class="line">        &#123;</span><br><span class="line">            min = prop;</span><br><span class="line">            maxPriority = priority;</span><br><span class="line">            source = layoutComp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If the layout component has the same priority as a previously used,</span></span><br><span class="line">        <span class="comment">// use the largest of the values with the same priority.</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prop &gt; min)</span><br><span class="line">        &#123;</span><br><span class="line">            min = prop;</span><br><span class="line">            source = layoutComp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListPool&lt;Component&gt;.Release(components);</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是通过获取子节点实现了<strong>ILayoutElement</strong>的Components，然后根据component的<strong>layoutPriority</strong>的值来获取高优先级的对应值。即同一个child，高layoutProiority的属性值会覆盖低layoutProiority的。</p>
<p>回到上面计算的代码，在得到child的各个类型的size之后，就可以根据<strong>alongAxis</strong>参数来进行高度的计算了，其实就是如果是对应轴的话，即非alongAxis的情况，对应的size就是叠加的，否则就是取最大值。</p>
<p>最后通过<strong>SetLayoutInputForAxis</strong>方法将所得到的size存储起来，方法如下</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetLayoutInputForAxis</span>(<span class="params"><span class="keyword">float</span> totalMin, <span class="keyword">float</span> totalPreferred, <span class="keyword">float</span> totalFlexible, <span class="keyword">int</span> axis</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_TotalMinSize[axis] = totalMin;</span><br><span class="line">    m_TotalPreferredSize[axis] = totalPreferred;</span><br><span class="line">    m_TotalFlexibleSize[axis] = totalFlexible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是继承自LayoutGroup的方法，LayoutGroup也实现了ILayoutElement接口，对应的xxxxWidth/xxxxHeight即从上面的变量中拿到对应轴向的size，0为水平，1为垂直。</p>
<p>计算布局部分就到这里结束了，这个部分之后我们就得到了LayoutGroup的各种size。接着就是根据size去设置child的位置以及size了。</p>
<h3 id="设置child位置以及大小的部分"><a href="#设置child位置以及大小的部分" class="headerlink" title="设置child位置以及大小的部分"></a>设置child位置以及大小的部分</h3><p>LayoutGroup实现了<strong>ILayoutController</strong>的接口，即需要实现<strong>SetLayoutHorizontal/Vertical</strong>方法，在上面代码展示中我们看到，其实本质也就是调用<strong>SetChildrenAlongAxis</strong>的方法，代码如下</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetChildrenAlongAxis</span>(<span class="params"><span class="keyword">int</span> axis, <span class="keyword">bool</span> isVertical</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> size = rectTransform.rect.size[axis];</span><br><span class="line">    <span class="keyword">bool</span> controlSize = (axis == <span class="number">0</span> ? m_ChildControlWidth : m_ChildControlHeight);</span><br><span class="line">    <span class="keyword">bool</span> childForceExpandSize = (axis == <span class="number">0</span> ? childForceExpandWidth : childForceExpandHeight);</span><br><span class="line">    <span class="keyword">float</span> alignmentOnAxis = GetAlignmentOnAxis(axis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> alongOtherAxis = (isVertical ^ (axis == <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (alongOtherAxis)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> innerSize = size - (axis == <span class="number">0</span> ? padding.horizontal : padding.vertical);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rectChildren.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            RectTransform child = rectChildren[i];</span><br><span class="line">            <span class="keyword">float</span> min, preferred, flexible;</span><br><span class="line">            GetChildSizes(child, axis, controlSize, childForceExpandSize, <span class="keyword">out</span> min, <span class="keyword">out</span> preferred, <span class="keyword">out</span> flexible);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> requiredSpace = Mathf.Clamp(innerSize, min, flexible &gt; <span class="number">0</span> ? size : preferred);</span><br><span class="line">            <span class="keyword">float</span> startOffset = GetStartOffset(axis, requiredSpace);</span><br><span class="line">            <span class="keyword">if</span> (controlSize)</span><br><span class="line">            &#123;</span><br><span class="line">                SetChildAlongAxis(child, axis, startOffset, requiredSpace);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">float</span> offsetInCell = (requiredSpace - child.sizeDelta[axis]) * alignmentOnAxis;</span><br><span class="line">                SetChildAlongAxis(child, axis, startOffset + offsetInCell);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> pos = (axis == <span class="number">0</span> ? padding.left : padding.top);</span><br><span class="line">        <span class="keyword">if</span> (GetTotalFlexibleSize(axis) == <span class="number">0</span> &amp;&amp; GetTotalPreferredSize(axis) &lt; size)</span><br><span class="line">            pos = GetStartOffset(axis, GetTotalPreferredSize(axis) - (axis == <span class="number">0</span> ? padding.horizontal : padding.vertical));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> minMaxLerp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (GetTotalMinSize(axis) != GetTotalPreferredSize(axis))</span><br><span class="line">            minMaxLerp = Mathf.Clamp01((size - GetTotalMinSize(axis)) / (GetTotalPreferredSize(axis) - GetTotalMinSize(axis)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> itemFlexibleMultiplier = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; GetTotalPreferredSize(axis))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (GetTotalFlexibleSize(axis) &gt; <span class="number">0</span>)</span><br><span class="line">                itemFlexibleMultiplier = (size - GetTotalPreferredSize(axis)) / GetTotalFlexibleSize(axis);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rectChildren.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            RectTransform child = rectChildren[i];</span><br><span class="line">            <span class="keyword">float</span> min, preferred, flexible;</span><br><span class="line">            GetChildSizes(child, axis, controlSize, childForceExpandSize, <span class="keyword">out</span> min, <span class="keyword">out</span> preferred, <span class="keyword">out</span> flexible);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> childSize = Mathf.Lerp(min, preferred, minMaxLerp);</span><br><span class="line">            childSize += flexible * itemFlexibleMultiplier;</span><br><span class="line">            <span class="keyword">if</span> (controlSize)</span><br><span class="line">            &#123;</span><br><span class="line">                SetChildAlongAxis(child, axis, pos, childSize);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">float</span> offsetInCell = (childSize - child.sizeDelta[axis]) * alignmentOnAxis;</span><br><span class="line">                SetChildAlongAxis(child, axis, pos + offsetInCell);</span><br><span class="line">            &#125;</span><br><span class="line">            pos += childSize + spacing;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是相比于CalcAlongAxis方法多了一个参数<strong>alignmentOnAxis</strong>，这个参数也就是根据面板里的Child Alignment来获得child应该偏移的位置。然后接着就是根据是否alongOtherAxis来确定child的size以及位置。</p>
<p>首先看alongOtherAxis的情况，我们同样使用<strong>GetChildSizes</strong>方法来获得child的各种size，然后根据是否是controlSize来对child的pos和size进行设置，<strong>这里不要忘记对应的各种size在GetChildSizes方法中也根据是否controlSize进行了处理</strong>。然后就是<strong>SetChildAlongAxis</strong>方法，代码如下</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetChildAlongAxis</span>(<span class="params">RectTransform rect, <span class="keyword">int</span> axis, <span class="keyword">float</span> pos, <span class="keyword">float</span> size</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rect == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    m_Tracker.Add(<span class="keyword">this</span>, rect,</span><br><span class="line">        DrivenTransformProperties.Anchors |</span><br><span class="line">        (axis == <span class="number">0</span> ?</span><br><span class="line">         (DrivenTransformProperties.AnchoredPositionX | DrivenTransformProperties.SizeDeltaX) :</span><br><span class="line">         (DrivenTransformProperties.AnchoredPositionY | DrivenTransformProperties.SizeDeltaY)</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">    rect.SetInsetAndSizeFromParentEdge(axis == <span class="number">0</span> ? RectTransform.Edge.Left : RectTransform.Edge.Top, pos, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即调用<strong>SetInsetAndSizeFromParentEdge</strong>方法来进行设置，方法如下</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetInsetAndSizeFromParentEdge</span>(<span class="params">RectTransform.Edge edge, <span class="keyword">float</span> inset, <span class="keyword">float</span> size</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> index = edge == RectTransform.Edge.Top || edge == RectTransform.Edge.Bottom ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">bool</span> flag = edge == RectTransform.Edge.Top || edge == RectTransform.Edge.Right;</span><br><span class="line">  <span class="keyword">float</span> num = !flag ? <span class="number">0.0f</span> : <span class="number">1f</span>;</span><br><span class="line">  Vector2 anchorMin = <span class="keyword">this</span>.anchorMin;</span><br><span class="line">  anchorMin[index] = num;</span><br><span class="line">  <span class="keyword">this</span>.anchorMin = anchorMin;</span><br><span class="line">  Vector2 anchorMax = <span class="keyword">this</span>.anchorMax;</span><br><span class="line">  anchorMax[index] = num;</span><br><span class="line">  <span class="keyword">this</span>.anchorMax = anchorMax;</span><br><span class="line">  Vector2 sizeDelta = <span class="keyword">this</span>.sizeDelta;</span><br><span class="line">  sizeDelta[index] = size;</span><br><span class="line">  <span class="keyword">this</span>.sizeDelta = sizeDelta;</span><br><span class="line">  Vector2 anchoredPosition = <span class="keyword">this</span>.anchoredPosition;</span><br><span class="line">  anchoredPosition[index] = !flag ? inset + size * <span class="keyword">this</span>.pivot[index] : (<span class="keyword">float</span>) (-(<span class="keyword">double</span>) inset - (<span class="keyword">double</span>) size * (<span class="number">1.0</span> - (<span class="keyword">double</span>) <span class="keyword">this</span>.pivot[index]));</span><br><span class="line">  <span class="keyword">this</span>.anchoredPosition = anchoredPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是RectTransform里面的方法，参数<strong>edge</strong>代表以父对象的哪一边为基准，<strong>inset</strong>代表距离所指定的edge的距离，<strong>size</strong>代表对应edge上rect的size（即top和bottom对应高度，left和right对应宽度)</p>
<p>了解了设置的方法，就可以回到上面的方法接着看各个size的含义了，首先是requiredSpace，即当前的child所需要的空间大小，根据child是否flex，将max设定在了LayoutGroup的rect的size或者child的prefered size，min即为child的min值(这里感觉说起来有点不太好理解，可以自行使用一个Horizontal Layout，然后把child的高度设置的比LayoutGroup的高度小，然后勾选Child Force Expand和control size试试)。</p>
<p>这里的startOffset是根据设置的childAlignment以及layoutGroup的rect的size以及传入的size来获取需要的偏移量。</p>
<p>然后就是根据是否contolSize来对child进行size的设置，如果是controlSize的话就会传入requiredSize来进行设置，非controlSize的话就会调用<strong>SetChildAlongAxis</strong>的同名重载函数，其实也就是使用了child本身的rectSize来作为size进行设置。</p>
<p>这里会有一个参数比较迷糊就是<strong>offsetInCell</strong>，其实就是因为上面的startOffset是根据requireSize来进行计算的，这里因为我们不使用requireSize来对childSize进行设置，而是使用child的rect的size，因此要加上差值。</p>
<p>直到这里，alongAxis的情况就看完了，接着就是非alongAxis的情况</p>
<p>其实和alongOtherAxis的情况差不多，只是pos会递增而已，这里不做多余的解释，就对涉及到的参数做一个讲解</p>
<ul>
<li><p><strong>pos</strong>：每个child在对应axis上的偏移量，如果LayoutGroup的rect有剩余空间并且不会被子物体expand(即totalFlex==0)的情况下就会根据设置的childAlignment有个初始位置偏移</p>
</li>
<li><p><strong>minMaxLerp</strong>：即当前的size小于LayoutGroup所需的PreferredSize的话，就会对所有的child进行一个等比例缩小。</p>
</li>
<li><p><strong>itemFlexibleMultiplier</strong>：即提供了flexSize的子物体，要占据剩余空间的每一份的大小，然后子物体的size会加上他们的flexSize*itemFlexibleMultiplier。举个例子就是有ABC三个子物体，totalPreferredSize的大小是100，然后LayoutGroup的size是200，A和C的flexible的值分别为1和9，那么这里的itemFlexibleMultiplier就是10，然后A和C的size分别会加上10和90。</p>
</li>
</ul>
<p>理解完参数之后再代入下面累加size，非along情况下设置child位置以及大小的部分也就结束了。</p>
<p>其实这个地方的代码很多感觉讲解都不是很明白，可以实际在项目里操作一下就知道每个参数是怎么控制的了。<strong>重要的就是了解非control size的情况下，我们所有的布局计算和设置都是依赖child当前的rect的size的。</strong></p>
<h2 id="GridLayoutGroup"><a href="#GridLayoutGroup" class="headerlink" title="GridLayoutGroup"></a>GridLayoutGroup</h2><p>GridLayoutGroup直接继承LayoutGroup类，同样实现了四个方法，我们依然通过这四个方法来进行查看，首先是CalculateLayoutXXXXx的方法</p>
<h3 id="计算布局部分-1"><a href="#计算布局部分-1" class="headerlink" title="计算布局部分"></a>计算布局部分</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">CalculateLayoutInputHorizontal</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">base</span>.CalculateLayoutInputHorizontal();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minColumns = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> preferredColumns = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_Constraint == Constraint.FixedColumnCount)</span><br><span class="line">    &#123;</span><br><span class="line">        minColumns = preferredColumns = m_ConstraintCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_Constraint == Constraint.FixedRowCount)</span><br><span class="line">    &#123;</span><br><span class="line">        minColumns = preferredColumns = Mathf.CeilToInt(rectChildren.Count / (<span class="keyword">float</span>)m_ConstraintCount - <span class="number">0.001f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        minColumns = <span class="number">1</span>;</span><br><span class="line">        preferredColumns = Mathf.CeilToInt(Mathf.Sqrt(rectChildren.Count));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SetLayoutInputForAxis(</span><br><span class="line">        padding.horizontal + (cellSize.x + spacing.x) * minColumns - spacing.x,</span><br><span class="line">        padding.horizontal + (cellSize.x + spacing.x) * preferredColumns - spacing.x,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">CalculateLayoutInputVertical</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minRows = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_Constraint == Constraint.FixedColumnCount)</span><br><span class="line">    &#123;</span><br><span class="line">        minRows = Mathf.CeilToInt(rectChildren.Count / (<span class="keyword">float</span>)m_ConstraintCount - <span class="number">0.001f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_Constraint == Constraint.FixedRowCount)</span><br><span class="line">    &#123;</span><br><span class="line">        minRows = m_ConstraintCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> width = rectTransform.rect.size.x;</span><br><span class="line">        <span class="keyword">int</span> cellCountX = Mathf.Max(<span class="number">1</span>, Mathf.FloorToInt((width - padding.horizontal + spacing.x + <span class="number">0.001f</span>) / (cellSize.x + spacing.x)));</span><br><span class="line">        minRows = Mathf.CeilToInt(rectChildren.Count / (<span class="keyword">float</span>)cellCountX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> minSpace = padding.vertical + (cellSize.y + spacing.y) * minRows - spacing.y;</span><br><span class="line">    SetLayoutInputForAxis(minSpace, minSpace, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依然从Horizontal看起来，代码较为简单，其实就是如果没有指定Constraint的话就用1作为minColumns，否则的话其他的就直接使用指定的值，因为是grid布局，所以我们限定了一个方向的cell个数，另一个方向有多少个cell也就明了了。然后根据cellsize计算需要的控空间。</p>
<p>Vertical方向上的话，根据horizontal不同的情况计算出对应的cell个数，然后计算size即可。</p>
<h3 id="设置child位置以及大小部分"><a href="#设置child位置以及大小部分" class="headerlink" title="设置child位置以及大小部分"></a>设置child位置以及大小部分</h3><p>GridLayout的SetHorizontal以及SetVertical也是调用了同一个方法<strong>SetCellsAlongAxis</strong>，指定了不同的轴向而已。这里直接看SetCellsAlongAxis方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetCellsAlongAxis</span>(<span class="params"><span class="keyword">int</span> axis</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Normally a Layout Controller should only set horizontal values when invoked for the horizontal axis</span></span><br><span class="line">    <span class="comment">// and only vertical values when invoked for the vertical axis.</span></span><br><span class="line">    <span class="comment">// However, in this case we set both the horizontal and vertical position when invoked for the vertical axis.</span></span><br><span class="line">    <span class="comment">// Since we only set the horizontal position and not the size, it shouldn&#x27;t affect children&#x27;s layout,</span></span><br><span class="line">    <span class="comment">// and thus shouldn&#x27;t break the rule that all horizontal layout must be calculated before all vertical layout.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (axis == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Only set the sizes when invoked for horizontal axis, not the positions.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rectChildren.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            RectTransform rect = rectChildren[i];</span><br><span class="line"></span><br><span class="line">            m_Tracker.Add(<span class="keyword">this</span>, rect,</span><br><span class="line">                DrivenTransformProperties.Anchors |</span><br><span class="line">                DrivenTransformProperties.AnchoredPosition |</span><br><span class="line">                DrivenTransformProperties.SizeDelta);</span><br><span class="line"></span><br><span class="line">            rect.anchorMin = Vector2.up;</span><br><span class="line">            rect.anchorMax = Vector2.up;</span><br><span class="line">            rect.sizeDelta = cellSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> width = rectTransform.rect.size.x;</span><br><span class="line">    <span class="keyword">float</span> height = rectTransform.rect.size.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cellCountX = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cellCountY = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_Constraint == Constraint.FixedColumnCount)</span><br><span class="line">    &#123;</span><br><span class="line">        cellCountX = m_ConstraintCount;</span><br><span class="line">        cellCountY = Mathf.CeilToInt(rectChildren.Count / (<span class="keyword">float</span>)cellCountX - <span class="number">0.001f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_Constraint == Constraint.FixedRowCount)</span><br><span class="line">    &#123;</span><br><span class="line">        cellCountY = m_ConstraintCount;</span><br><span class="line">        cellCountX = Mathf.CeilToInt(rectChildren.Count / (<span class="keyword">float</span>)cellCountY - <span class="number">0.001f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cellSize.x + spacing.x &lt;= <span class="number">0</span>)</span><br><span class="line">            cellCountX = <span class="keyword">int</span>.MaxValue;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cellCountX = Mathf.Max(<span class="number">1</span>, Mathf.FloorToInt((width - padding.horizontal + spacing.x + <span class="number">0.001f</span>) / (cellSize.x + spacing.x)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cellSize.y + spacing.y &lt;= <span class="number">0</span>)</span><br><span class="line">            cellCountY = <span class="keyword">int</span>.MaxValue;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cellCountY = Mathf.Max(<span class="number">1</span>, Mathf.FloorToInt((height - padding.vertical + spacing.y + <span class="number">0.001f</span>) / (cellSize.y + spacing.y)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cornerX = (<span class="keyword">int</span>)startCorner % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> cornerY = (<span class="keyword">int</span>)startCorner / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cellsPerMainAxis, actualCellCountX, actualCellCountY;</span><br><span class="line">    <span class="keyword">if</span> (startAxis == Axis.Horizontal)</span><br><span class="line">    &#123;</span><br><span class="line">        cellsPerMainAxis = cellCountX;</span><br><span class="line">        actualCellCountX = Mathf.Clamp(cellCountX, <span class="number">1</span>, rectChildren.Count);</span><br><span class="line">        actualCellCountY = Mathf.Clamp(cellCountY, <span class="number">1</span>, Mathf.CeilToInt(rectChildren.Count / (<span class="keyword">float</span>)cellsPerMainAxis));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cellsPerMainAxis = cellCountY;</span><br><span class="line">        actualCellCountY = Mathf.Clamp(cellCountY, <span class="number">1</span>, rectChildren.Count);</span><br><span class="line">        actualCellCountX = Mathf.Clamp(cellCountX, <span class="number">1</span>, Mathf.CeilToInt(rectChildren.Count / (<span class="keyword">float</span>)cellsPerMainAxis));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector2 requiredSpace = <span class="keyword">new</span> Vector2(</span><br><span class="line">            actualCellCountX * cellSize.x + (actualCellCountX - <span class="number">1</span>) * spacing.x,</span><br><span class="line">            actualCellCountY * cellSize.y + (actualCellCountY - <span class="number">1</span>) * spacing.y</span><br><span class="line">            );</span><br><span class="line">    Vector2 startOffset = <span class="keyword">new</span> Vector2(</span><br><span class="line">            GetStartOffset(<span class="number">0</span>, requiredSpace.x),</span><br><span class="line">            GetStartOffset(<span class="number">1</span>, requiredSpace.y)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rectChildren.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> positionX;</span><br><span class="line">        <span class="keyword">int</span> positionY;</span><br><span class="line">        <span class="keyword">if</span> (startAxis == Axis.Horizontal)</span><br><span class="line">        &#123;</span><br><span class="line">            positionX = i % cellsPerMainAxis;</span><br><span class="line">            positionY = i / cellsPerMainAxis;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            positionX = i / cellsPerMainAxis;</span><br><span class="line">            positionY = i % cellsPerMainAxis;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cornerX == <span class="number">1</span>)</span><br><span class="line">            positionX = actualCellCountX - <span class="number">1</span> - positionX;</span><br><span class="line">        <span class="keyword">if</span> (cornerY == <span class="number">1</span>)</span><br><span class="line">            positionY = actualCellCountY - <span class="number">1</span> - positionY;</span><br><span class="line"></span><br><span class="line">        SetChildAlongAxis(rectChildren[i], <span class="number">0</span>, startOffset.x + (cellSize[<span class="number">0</span>] + spacing[<span class="number">0</span>]) * positionX, cellSize[<span class="number">0</span>]);</span><br><span class="line">        SetChildAlongAxis(rectChildren[i], <span class="number">1</span>, startOffset.y + (cellSize[<span class="number">1</span>] + spacing[<span class="number">1</span>]) * positionY, cellSize[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是一开始的代码直接处理了axis为0的(即设置水平child)情况，上面的注释也说了，在GridLayout中，SetHorizontal方法只是设置了child的<strong>anchorMin/Max</strong>以及<strong>sizeDelta</strong>。</p>
<p>然后就是SetVertical的情况，这里依然对几个参数进行解释，计算步骤不做多余的记录。</p>
<ul>
<li><p><strong>cellCountY/X</strong>：即根据面板参数算出来的对应axis上的cell个数。</p>
</li>
<li><p><strong>cellsPerMainAxis/actualCellCountX/actualCellCountX</strong>：其实就是根据StartAxis参数决定以哪边为主轴，然后使用主轴去计算另外一边的cell个数，主要解决指定的ConstraintCount大于了childrenCount或者flex情况下计算的width以及height不够大的情况。</p>
</li>
<li><p><strong>cornerX/Y</strong>：这个就和之前的Alignment一样，利用%和/来获得是否从右开始以及从下开始。然后如果是的话cell的位置就要进行一个翻转。</p>
</li>
</ul>
<p>最后就是利用之前提到SetChildAlongAxis的方法设置进去。</p>
<h2 id="ContentSizeFitter"><a href="#ContentSizeFitter" class="headerlink" title="ContentSizeFitter"></a>ContentSizeFitter</h2><p>ContentSizeFitter实现了<strong>ILayoutSelfController</strong>接口，没啥关键的方法，其实就是SetLayoutXXXX的方法里调用了<strong>HandleSelfFittingAlongAxis</strong>，代码如下</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleSelfFittingAlongAxis</span>(<span class="params"><span class="keyword">int</span> axis</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FitMode fitting = (axis == <span class="number">0</span> ? horizontalFit : verticalFit);</span><br><span class="line">    <span class="keyword">if</span> (fitting == FitMode.Unconstrained)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Keep a reference to the tracked transform, but don&#x27;t control its properties:</span></span><br><span class="line">        m_Tracker.Add(<span class="keyword">this</span>, rectTransform, DrivenTransformProperties.None);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_Tracker.Add(<span class="keyword">this</span>, rectTransform, (axis == <span class="number">0</span> ? DrivenTransformProperties.SizeDeltaX : DrivenTransformProperties.SizeDeltaY));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set size to min or preferred size</span></span><br><span class="line">    <span class="keyword">if</span> (fitting == FitMode.MinSize)</span><br><span class="line">        rectTransform.SetSizeWithCurrentAnchors((RectTransform.Axis)axis, LayoutUtility.GetMinSize(m_Rect, axis));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rectTransform.SetSizeWithCurrentAnchors((RectTransform.Axis)axis, LayoutUtility.GetPreferredSize(m_Rect, axis));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是设置本身的大小，没啥好看的。</p>
<h2 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h2><p>了解各个LayoutGroup的计算布局以及设置的方法，接下来需要看一下是如何调用的，顺着代码往上走，发现是在<strong>Rebuilder.cs</strong>里面的<strong>Rebuild</strong>方法里调用的，代码如下</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Rebuild</span>(<span class="params">CanvasUpdate executing</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (executing)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> CanvasUpdate.Layout:</span><br><span class="line">            <span class="comment">// It&#x27;s unfortunate that we&#x27;ll perform the same GetComponents querys for the tree 2 times,</span></span><br><span class="line">            <span class="comment">// but each tree have to be fully iterated before going to the next action,</span></span><br><span class="line">            <span class="comment">// so reusing the results would entail storing results in a Dictionary or similar,</span></span><br><span class="line">            <span class="comment">// which is probably a bigger overhead than performing GetComponents multiple times.</span></span><br><span class="line">            PerformLayoutCalculation(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutElement).CalculateLayoutInputHorizontal());</span><br><span class="line">            PerformLayoutControl(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutController).SetLayoutHorizontal());</span><br><span class="line">            PerformLayoutCalculation(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutElement).CalculateLayoutInputVertical());</span><br><span class="line">            PerformLayoutControl(m_ToRebuild, e =&gt; (e <span class="keyword">as</span> ILayoutController).SetLayoutVertical());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后接着看所调用的两个方法，即<strong>PerformLayoutCalculation</strong>和<strong>PerformLayoutControl</strong>，这里需要注意的是，他们分别属于不同的接口。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PerformLayoutCalculation</span>(<span class="params">RectTransform rect, UnityAction&lt;Component&gt; action</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rect == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class="line">    rect.GetComponents(<span class="keyword">typeof</span>(ILayoutElement), components);</span><br><span class="line">    StripDisabledBehavioursFromList(components);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are no controllers on this rect we can skip this entire sub-tree</span></span><br><span class="line">    <span class="comment">// We don&#x27;t need to consider controllers on children deeper in the sub-tree either,</span></span><br><span class="line">    <span class="comment">// since they will be their own roots.</span></span><br><span class="line">    <span class="keyword">if</span> (components.Count &gt; <span class="number">0</span>  || rect.GetComponent(<span class="keyword">typeof</span>(ILayoutGroup)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Layout calculations needs to executed bottom up with children being done before their parents,</span></span><br><span class="line">        <span class="comment">// because the parent calculated sizes rely on the sizes of the children.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rect.childCount; i++)</span><br><span class="line">            PerformLayoutCalculation(rect.GetChild(i) <span class="keyword">as</span> RectTransform, action);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; components.Count; i++)</span><br><span class="line">            action(components[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListPool&lt;Component&gt;.Release(components);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PerformLayoutControl</span>(<span class="params">RectTransform rect, UnityAction&lt;Component&gt; action</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rect == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class="line">    rect.GetComponents(<span class="keyword">typeof</span>(ILayoutController), components);</span><br><span class="line">    StripDisabledBehavioursFromList(components);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are no controllers on this rect we can skip this entire sub-tree</span></span><br><span class="line">    <span class="comment">// We don&#x27;t need to consider controllers on children deeper in the sub-tree either,</span></span><br><span class="line">    <span class="comment">// since they will be their own roots.</span></span><br><span class="line">    <span class="keyword">if</span> (components.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Layout control needs to executed top down with parents being done before their children,</span></span><br><span class="line">        <span class="comment">// because the children rely on the sizes of the parents.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// First call layout controllers that may change their own RectTransform</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; components.Count; i++)</span><br><span class="line">            <span class="keyword">if</span> (components[i] <span class="keyword">is</span> ILayoutSelfController)</span><br><span class="line">                action(components[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Then call the remaining, such as layout groups that change their children, taking their own RectTransform size into account.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; components.Count; i++)</span><br><span class="line">            <span class="keyword">if</span> (!(components[i] <span class="keyword">is</span> ILayoutSelfController))</span><br><span class="line">                action(components[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rect.childCount; i++)</span><br><span class="line">            PerformLayoutControl(rect.GetChild(i) <span class="keyword">as</span> RectTransform, action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListPool&lt;Component&gt;.Release(components);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是<strong>StripDisabledBehavioursFromList</strong>这个方法，其实就是过滤了一些没有启用的component。不做多余展示</p>
<p>然后其实直接看代码就知道大概逻辑了，需要注意的点是</p>
<p><strong>PerformLayoutCalculation方法是先执行递归，再进行action，即计算布局的时候是先计算子节点的size，然后再计算父节点的，而PerformLayoutControl方法是先进行action，然后在执行递归，即在进行布局控制的时候，我们是先控制了父节点的，再控制子节点的。</strong></p>
<p><strong>还有一个需要注意的点就是在布局控制的时候我们先执行了ILayoutSelfController的component的布局控制。</strong>即最优先进行了自身的布局控制。</p>
<p>接着往上看Rebuilder调用的地方，就到了<strong>CanvasUpdateRegistry.cs</strong>这个类，这个类之后会单独通过源代码来看，这里大概就知道<strong>在canvas执行更新方法的时候，会从更新队列里拿到所有的rebuilder执行rebuild方法</strong>。</p>
<p>那么我们是何时将layoutGroup注册到这个更新队列里呢，其实就是在<strong>LayoutGroup.cs的SetDirty这个方法</strong>里，代码如下</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SetDirty</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsActive())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!CanvasUpdateRegistry.IsRebuildingLayout())</span><br><span class="line">        LayoutRebuilder.MarkLayoutForRebuild(rectTransform);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        StartCoroutine(DelayedSetDirty(rectTransform));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LayoutGroup会在各个生命流程方法里调用这个方法。这样在canvasUpdate的时候就会对标记的rect进行rebuild layout。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/14/hello-world/" rel="prev" title="第一篇博客要给我最可爱滴居居！！">
      <i class="fa fa-chevron-left"></i> 第一篇博客要给我最可爱滴居居！！
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#HorizontalLayoutGroup%E5%92%8CVerticalLayoutGroup"><span class="nav-number">1.</span> <span class="nav-text">HorizontalLayoutGroup和VerticalLayoutGroup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HorizontalOrVerticalLayoutGroup"><span class="nav-number">2.</span> <span class="nav-text">HorizontalOrVerticalLayoutGroup</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%B8%83%E5%B1%80%E9%83%A8%E5%88%86"><span class="nav-number">2.1.</span> <span class="nav-text">计算布局部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AEchild%E4%BD%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%A4%A7%E5%B0%8F%E7%9A%84%E9%83%A8%E5%88%86"><span class="nav-number">2.2.</span> <span class="nav-text">设置child位置以及大小的部分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GridLayoutGroup"><span class="nav-number">3.</span> <span class="nav-text">GridLayoutGroup</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%B8%83%E5%B1%80%E9%83%A8%E5%88%86-1"><span class="nav-number">3.1.</span> <span class="nav-text">计算布局部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AEchild%E4%BD%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%A4%A7%E5%B0%8F%E9%83%A8%E5%88%86"><span class="nav-number">3.2.</span> <span class="nav-text">设置child位置以及大小部分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ContentSizeFitter"><span class="nav-number">4.</span> <span class="nav-text">ContentSizeFitter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="nav-number">5.</span> <span class="nav-text">调用时机</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jechyang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jechyang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'TR1xGQoKWd32OCfGbfWF2i1k-gzGzoHsz',
      appKey     : 'rWx9cqwpLPG1sbENDhL4dTxK',
      placeholder: "欢迎进行讨论",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
